<body style="margin:0;background:#2E5077">
  <canvas id=a>
    <script>
      // initialize 2D canvas (c)
      // initialize game state (s)
      // initialize keys states (u,r,d,l for directions, k for all the keyboard)
      c = a.getContext`2d`, k = [u = r = d = l = s = 0]
      // (initialize your global variables here)
      tt = 0//current time
      BLOCK_SIZE = 32
      COLORS = ["#611C35", "#4DA1A9", "#D7E8BA", "#FFA630"]
      p = { vx: 0, vy: 0, x: 8 * BLOCK_SIZE, y: 30 * BLOCK_SIZE, w: BLOCK_SIZE - .5, h: BLOCK_SIZE, recentCollision: -1 } //the player
      gamemap = [{
        //floor
        x: 0,
        y: 0,
        w: 300,
        h: 1
      }, /*{
        x: 2,
        y: 5,
        w: 5,
        h: 1
      }, {
        x: 6,
        y: 8,
        w: 5,
        h: 1
      }, {
        x: 4,
        y: 12,
        w: 5,
        h: 1
      }, {
        x: 12,
        y: 8,
        w: 5,
        h: 1
      }, {
        x: 25,
        y: 3,
        w: 5,
        h: 5
      }, {
        x: 15,
        y: 0,
        w: 2,
        h: 2,
        bad: 1
      }*/]

      // update u,l,d,r globals when an arrow key/wasd/zqsd is pressed or released
      // update k[keyCode] if any other key is pressed/released
      ontouchstart = ontouchmove = e => { l = e.touches[0].clientX < w / 2; r = !l; u = e.touches.length > 1 }
      ontouchend = e => { u = 0; l = r = e.touches.length } //reset movement on touch end
      onkeydown = onkeyup = e => k[e.which] = self['lld*rlurdu'[e.which % 32 % 17]] = e.type[5]

      lim = (x, min, max) => x < min ? min : x > max ? max : x; //limits the number to the range [min, max]
      collision = (r1, r2) => r1.x + r1.w > r2.x && r1.x < r2.x + r2.w && r2.y + r2.h > r1.y && r2.y < r1.y + r1.h
      setC = (index) => c.fillStyle = COLORS[index]
      rnd = (min, max) => ~~(Math.random() * (max - min) + min)
      /* RANDOM GENERATION*/
      for (index = 10; index--;)
        gamemap.push({ x: rnd(0, 40), y: rnd(2, 20), w: rnd(4, 10), h: rnd(0, 4) < 3 ? 1 : rnd(1, 6) })
      for (index = 5; index--;)
        gamemap.push({ x: rnd(0, 40), y: rnd(2, 20), w: rnd(1, 4), h: rnd(1, 4), bad: 1 })

      /* TILED MAP READER
      tiledData = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      TILED_WIDTH = 40
      TILED_HEIGHT = 30
      for (i = tiledData.length; i--;) {
        const element = tiledData[i];
        if (element > 0)
          gamemap.push({ x: i % TILED_WIDTH, y: TILED_HEIGHT - ~~(i / TILED_WIDTH), w: 1, h: 1 })
      }*/

      for (b of gamemap)
        for (key in b)
          b[key] *= BLOCK_SIZE

      // start game loop (60fps)
      // the canvas is cleared and adjusted to fullscreen at each frame
      // draw each screen in the switch's cases
      // in each screen, you can make key presses update the game state
      // ex: "press enter to open the menu" => `if(k[13])s=1;`
      setInterval(e => {
        w = innerWidth, h = innerHeight

        draw = (x, y, w, he) => c.fillRect(x, h - y - he, w, he)
        a.width = w, a.height = h;

        c.font = "100px Impact";
        switch (s) {

          case 1: // main game
            p.recentCollision--;

            //TODO: These two loops could be made into one / function call?
            //do collision checking in y direction
            p.y += p.vy;
            for (b of gamemap)
              if (collision(p, b)) //the overlap occured on the y axis
              //determine the distance, so we don't overlap, and move back by that amount
              {
                if (p.vy < 0) p.recentCollision = 4;
                p.y = p.vy > 0 ? b.y - p.h : b.h + b.y; p.vy = 0;
                if ('bad' in b) p.y = p.x = 12 * BLOCK_SIZE //GAME OVER
              }
            //do collision checking in x direction
            p.x += p.vx;
            for (b of gamemap)
              if (collision(p, b)) //the overlap occured on the x axis
              //determine the distance, so we don't overlap, and move back by that amount
              {
                p.x = p.vx > 0 ? b.x - p.w : b.w + b.x; p.vx = 0;
                if ('bad' in b) p.y = p.x = 20 * BLOCK_SIZE //GAME OVER
              }

            p.vx = lim(p.vx + (!r && !l ? -p.vx / 8 : (!l - !r) / 4), -5, 5);
            p.vy = lim(p.vy - 0.25 + (!!u && p.recentCollision > 0 ? 10 : 0) /* if jump button is pressed and we recently hit the ground, accel upward*/, -10, 10);  //player movement and gravity (limit max speed)
            p.x = (p.x + w) % w;

          case 0: setC(1); c.fillText("404 Page not found", 20, h / 2 - tt * h / 300);
            if (tt > 90) s = 1; else tt++; // ex: draw title screen

            for (b of gamemap) {
              // RENDERING
              if ('bad' in b) {
                setC(0)
                draw(b.x, b.y, b.w, b.h)
              } else {
                setC(2)
                draw(b.x, b.y, b.w, b.h)
                setC(1)
                c.fillRect(b.x, h - b.y - b.h, b.w, BLOCK_SIZE / 3)
              }
            }
            setC(3); draw(p.x, p.y, BLOCK_SIZE, BLOCK_SIZE);
            break
        }
      }, 7)

      // handle click/touch events
      // globals x and y contain the pointer's coordinates
      // in each screen, you can make a click update the game state
      // ex: "game over if we click on the bottom half of the screen" => `if (y > h / 2) s = 3;`
      onclick = e => {
        x = e.pageX; y = e.pageY;
        switch (s) {
          case 0: // react to clicks on screen 0
          case 1: // react to clicks on screen 1
          case 2: // react to clicks on screen 2
          case 3: // react to clicks on screen 3
        }
      }
    </script>